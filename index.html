<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soundscape Visualizer</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;700&family=Roboto:wght@300;400;500&display=swap">
    <style>
        :root {
            --primary: #6200ea;
            --primary-light: #9d46ff;
            --primary-dark: #0a00b6;
            --secondary: #00e5ff;
            --secondary-light: #6effff;
            --secondary-dark: #00b2cc;
            --text-light: #ffffff;
            --text-dark: #121212;
            --background: #121212;
            --background-light: #2a2a2a;
            --accent: #ff3d00;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            background-color: var(--background);
            color: var(--text-light);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }

        header {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            padding: 1.5rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 10;
        }

        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .logo {
            display: flex;
            align-items: center;
            font-size: 1.8rem;
            font-weight: 700;
        }

        .logo-icon {
            margin-right: 0.5rem;
            font-size: 2rem;
        }

        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 2rem;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        .controls-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            background: var(--background-light);
            padding: 1.5rem;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        .visualizer-container {
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            overflow: hidden;
            min-height: 60vh;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .visualizer-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .control-group {
            flex: 1;
            min-width: 280px;
        }

        .control-group h3 {
            margin-bottom: 1rem;
            font-size: 1rem;
            font-weight: 600;
            color: var(--secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: var(--text-light);
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .btn:hover {
            background: linear-gradient(135deg, var(--primary-light), var(--primary));
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-record {
            background: linear-gradient(135deg, var(--accent), #ff6e40);
        }

        .btn-record.recording {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            animation: pulse 1.5s infinite;
        }

        .select-wrapper {
            position: relative;
            margin-bottom: 1.5rem;
        }

        select {
            width: 100%;
            padding: 0.8rem 1rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background-color: rgba(0, 0, 0, 0.3);
            color: var(--text-light);
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem;
            appearance: none;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        select:focus {
            outline: none;
            border-color: var(--secondary);
            box-shadow: 0 0 0 2px rgba(0, 229, 255, 0.3);
        }

        .select-wrapper::after {
            content: 'â–¼';
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            font-size: 0.8rem;
            color: var(--secondary);
        }

        .slider-container {
            margin-bottom: 1.5rem;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: var(--background);
            border-radius: 3px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--secondary);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            background: var(--secondary-light);
            transform: scale(1.2);
        }

        .color-picker {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .color-input {
            -webkit-appearance: none;
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 8px;
            background: transparent;
            cursor: pointer;
        }

        .color-input::-webkit-color-swatch {
            border: none;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            margin-top: 1rem;
        }

        .indicator-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #888;
        }

        .indicator-dot.active {
            background-color: var(--accent);
            box-shadow: 0 0 10px var(--accent);
        }

        .preset-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .preset-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .preset-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .preset-btn.active {
            background: var(--secondary-dark);
            border-color: var(--secondary);
            color: var(--text-light);
        }

        footer {
            text-align: center;
            padding: 1.5rem;
            background-color: var(--background-light);
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.5);
        }

        .visualizer-info {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: rgba(0, 0, 0, 0.6);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
            z-index: 2;
            transition: opacity 0.3s ease;
        }

        .audio-wave {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            z-index: 1;
        }

        .wave-bar {
            width: 4px;
            height: 3px;
            background: var(--secondary);
            margin: 0 2px;
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        /* Animations */
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 61, 0, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(255, 61, 0, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 61, 0, 0);
            }
        }

        /* Responsiveness */
        @media (max-width: 768px) {
            .main-container {
                padding: 1rem;
            }
            
            .controls-container {
                flex-direction: column;
                gap: 1rem;
                padding: 1rem;
            }
            
            .control-group {
                min-width: 100%;
            }
            
            .visualizer-container {
                min-height: 40vh;
            }
            
            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <header>
        <nav>
            <div class="logo">
                <span class="logo-icon">ðŸŽµ</span>
                <span>Soundscape Visualizer</span>
            </div>
        </nav>
    </header>

    <div class="main-container">
        <div class="controls-container">
            <div class="control-group">
                <h3>Visualization</h3>
                <div class="select-wrapper">
                    <select id="visualizationType">
                        <option value="bars">Classic Bars</option>
                        <option value="circular">Circular</option>
                        <option value="wave">Wave</option>
                        <option value="spectrum">Spectrum</option>
                        <option value="particles">Particles</option>
                        <option value="terrain">3D Terrain</option>
                        <option value="guitarHero">Guitar Hero</option>
                        <option value="starfield">Starfield</option>
                        <option value="frequency">Frequency Mesh</option>
                        <option value="orbs">Energy Orbs</option>
                        <option value="ripple">Ripple</option>
                        <option value="waveform">Waveform</option>
                        <option value="fractal">Fractal</option>
                        <option value="spiral">Spiral</option>
                        <option value="bubbles">Bubbles</option>
                        <option value="fireflies">Fireflies</option>
                        <option value="grid">Grid</option>
                        <option value="tunnel">Tunnel</option>
                        <option value="galaxy">Galaxy</option>
                        <option value="matrix">Matrix</option>
                        <option value="surface3d">Surface 3D</option>
                    </select>
                </div>

                <div class="preset-buttons">
                    <button class="preset-btn active" data-preset="default">Default</button>
                    <button class="preset-btn" data-preset="neon">Neon</button>
                    <button class="preset-btn" data-preset="minimal">Minimal</button>
                    <button class="preset-btn" data-preset="dark">Dark</button>
                    <button class="preset-btn" data-preset="retro">Retro</button>
                </div>
            </div>

            <div class="control-group">
                <h3>Audio Controls</h3>
                <button id="recordButton" class="btn btn-record">
                    <span class="btn-icon">ðŸŽ¤</span>
                    <span class="btn-text">Start Recording</span>
                </button>
                <button id="fullscreenButton" class="btn" style="margin-top:1rem;">
                    <span class="btn-icon">â›¶</span>
                    <span class="btn-text">Full Screen</span>
                </button>
                
                <div class="status-indicator">
                    <div id="recordingIndicator" class="indicator-dot"></div>
                    <span id="recordingStatus">Not recording</span>
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Sensitivity</span>
                        <span id="sensitivityValue">5</span>
                    </div>
                    <input type="range" min="1" max="10" value="5" class="slider" id="sensitivitySlider">
                </div>
            </div>

            <div class="control-group">
                <h3>Appearance</h3>
                <div class="color-picker">
                    <input type="color" class="color-input" id="primaryColor" value="#9d46ff">
                    <input type="color" class="color-input" id="secondaryColor" value="#00e5ff">
                    <input type="color" class="color-input" id="backgroundColor" value="#121212">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Animation Speed</span>
                        <span id="speedValue">5</span>
                    </div>
                    <input type="range" min="1" max="10" value="5" class="slider" id="speedSlider">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Intensity</span>
                        <span id="intensityValue">5</span>
                    </div>
                    <input type="range" min="1" max="10" value="5" class="slider" id="intensitySlider">
                </div>
            </div>

            <div class="control-group" id="matrixSettingsGroup" style="display:none;">
                <h3>Matrix Settings</h3>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Font Size</span>
                        <span id="matrixFontSizeValue">16</span>
                    </div>
                    <input type="range" min="10" max="40" value="16" class="slider" id="matrixFontSizeSlider">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Speed</span>
                        <span id="matrixSpeedValue">5</span>
                    </div>
                    <input type="range" min="1" max="20" value="5" class="slider" id="matrixSpeedSlider">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Charset</span>
                    </div>
                    <input type="text" id="matrixCharsetInput" value="ã‚¢ã‚¡ã‚«ã‚µã‚¿ãƒŠãƒãƒžãƒ¤ãƒ£ãƒ©ãƒ¯ã‚¬ã‚¶ãƒ€ãƒãƒ‘ã‚¤ã‚£ã‚­ã‚·ãƒãƒ‹ãƒ’ãƒŸãƒªãƒ°ã‚®ã‚¸ãƒ‚ãƒ“ãƒ”ã‚¦ã‚¥ã‚¯ã‚¹ãƒ„ãƒŒãƒ•ãƒ ãƒ¦ãƒ¥ãƒ«ã‚°ã‚ºãƒ…ãƒ–ãƒ—ã‚¨ã‚§ã‚±ã‚»ãƒ†ãƒãƒ˜ãƒ¡ãƒ¬ãƒ±ã‚²ã‚¼ãƒ‡ãƒ™ãƒšã‚ªã‚©ã‚³ã‚½ãƒˆãƒŽãƒ›ãƒ¢ãƒ¨ãƒ§ãƒ­ãƒ²ã‚´ã‚¾ãƒ‰ãƒœãƒãƒ´ãƒƒãƒ³ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" style="width:100%;padding:0.5rem;border-radius:6px;border:1px solid #333;background:#181818;color:#fff;">
                </div>
            </div>

            <div class="control-group" id="starfieldThemesGroup" style="display:none;">
                <h3>Starfield Themes</h3>
                <div class="preset-buttons" id="starfieldThemeButtons"></div>
            </div>

            <div class="control-group" id="surface3dSettingsGroup" style="display:none;">
                <h3>Surface 3D Themes</h3>
                <div class="preset-buttons" id="surface3dThemeButtons"></div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Color Map</span>
                        <select id="surface3dColormap" style="padding:0.3rem 1rem;border-radius:6px;">
                            <option value="rainbow">Rainbow</option>
                            <option value="hot">Hot</option>
                            <option value="cool">Cool</option>
                            <option value="inferno">Inferno</option>
                            <option value="magma">Magma</option>
                            <option value="viridis">Viridis</option>
                        </select>
                    </div>
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Perspective</span>
                        <span id="surface3dPerspectiveValue">1.2</span>
                    </div>
                    <input type="range" min="0.5" max="2" step="0.01" value="1.2" class="slider" id="surface3dPerspectiveSlider">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Rotation</span>
                        <span id="surface3dRotationValue">0</span>
                    </div>
                    <input type="range" min="-1" max="1" step="0.01" value="0" class="slider" id="surface3dRotationSlider">
                </div>
            </div>
        </div>

        <div class="visualizer-container">
            <div class="visualizer-info">
                <span id="currentVisualizer">Classic Bars</span>
            </div>
            <canvas id="visualizerCanvas" class="visualizer-canvas"></canvas>
            <div id="audioWave" class="audio-wave"></div>
        </div>
    </div>

    <footer>
        <p>Â© 2023 Soundscape Visualizer | Create stunning audio visualizations with your microphone</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // DOM Elements
            const visualizerCanvas = document.getElementById('visualizerCanvas');
            const ctx = visualizerCanvas.getContext('2d');
            const recordButton = document.getElementById('recordButton');
            const recordingIndicator = document.getElementById('recordingIndicator');
            const recordingStatus = document.getElementById('recordingStatus');
            const visualizationType = document.getElementById('visualizationType');
            const sensitivitySlider = document.getElementById('sensitivitySlider');
            const sensitivityValue = document.getElementById('sensitivityValue');
            const speedSlider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            const intensitySlider = document.getElementById('intensitySlider');
            const intensityValue = document.getElementById('intensityValue');
            const primaryColor = document.getElementById('primaryColor');
            const secondaryColor = document.getElementById('secondaryColor');
            const backgroundColor = document.getElementById('backgroundColor');
            const currentVisualizer = document.getElementById('currentVisualizer');
            const audioWave = document.getElementById('audioWave');
            const presetButtons = document.querySelectorAll('.preset-btn');
            const fullscreenButton = document.getElementById('fullscreenButton');
            const visualizerContainer = document.querySelector('.visualizer-container');
            const matrixSettingsGroup = document.getElementById('matrixSettingsGroup');
            const matrixFontSizeSlider = document.getElementById('matrixFontSizeSlider');
            const matrixFontSizeValue = document.getElementById('matrixFontSizeValue');
            const matrixSpeedSlider = document.getElementById('matrixSpeedSlider');
            const matrixSpeedValue = document.getElementById('matrixSpeedValue');
            const matrixCharsetInput = document.getElementById('matrixCharsetInput');
            const starfieldThemesGroup = document.getElementById('starfieldThemesGroup');
            const starfieldThemeButtons = document.getElementById('starfieldThemeButtons');
            const surface3dSettingsGroup = document.getElementById('surface3dSettingsGroup');
            const surface3dThemeButtons = document.getElementById('surface3dThemeButtons');
            const surface3dColormap = document.getElementById('surface3dColormap');
            const surface3dPerspectiveSlider = document.getElementById('surface3dPerspectiveSlider');
            const surface3dPerspectiveValue = document.getElementById('surface3dPerspectiveValue');
            const surface3dRotationSlider = document.getElementById('surface3dRotationSlider');
            const surface3dRotationValue = document.getElementById('surface3dRotationValue');

            // Audio variables
            let audioContext;
            let analyser;
            let microphone;
            let dataArray = [];
            let isRecording = false;
            let animationId;
            let sensitivity = 5;
            let speed = 5;
            let intensity = 5;
            let visualizerType = 'bars';
            let matrixFontSize = 16;
            let matrixSpeed = 5;
            let matrixCharset = matrixCharsetInput.value;
            let matrixColumns = [];
            let matrixDrops = [];
            let currentStarfieldTheme = 0;
            let currentSurface3dTheme = 0;
            let surface3dColormapValue = "rainbow";
            let surface3dPerspective = 1.2;
            let surface3dRotation = 0;

            // Starfield themes
            const starfieldThemes = [
                { name: "Classic", bg: "#111", color: "#fff", explode: false, trail: false, bassExplode: false },
                { name: "Neon Blue", bg: "#0a192f", color: "#00eaff", explode: true, trail: true, bassExplode: true },
                { name: "Purple Dream", bg: "#2d0036", color: "#e600ff", explode: true, trail: false, bassExplode: false },
                { name: "Retro Sun", bg: "#ffb347", color: "#ff0099", explode: true, trail: true, bassExplode: true },
                { name: "Matrix Green", bg: "#001a00", color: "#00ff41", explode: false, trail: true, bassExplode: false },
                { name: "Firestorm", bg: "#1a0000", color: "#ff5400", explode: true, trail: false, bassExplode: true },
                { name: "Ice World", bg: "#001f3f", color: "#7fdbff", explode: false, trail: true, bassExplode: false },
                { name: "Cyberpunk", bg: "#120458", color: "#ff00a0", explode: true, trail: true, bassExplode: true },
                { name: "Emerald", bg: "#011627", color: "#2ec4b6", explode: false, trail: false, bassExplode: false },
                { name: "Sunset", bg: "#220901", color: "#ff7b00", explode: true, trail: true, bassExplode: false },
                { name: "Aurora", bg: "#001d3d", color: "#00ffb3", explode: true, trail: false, bassExplode: true },
                { name: "Gold Rush", bg: "#2d1600", color: "#ffd700", explode: false, trail: true, bassExplode: false },
                { name: "Pink Pop", bg: "#3a0ca3", color: "#ff61a6", explode: true, trail: true, bassExplode: true },
                { name: "Deep Space", bg: "#000814", color: "#00b4d8", explode: false, trail: false, bassExplode: false },
                { name: "Lime Glow", bg: "#142f01", color: "#baff39", explode: true, trail: false, bassExplode: true },
                { name: "Vaporwave", bg: "#ffb3c6", color: "#a0c4ff", explode: true, trail: true, bassExplode: false },
                { name: "Red Alert", bg: "#2d0000", color: "#ff1744", explode: true, trail: false, bassExplode: true },
                { name: "Oceanic", bg: "#001f54", color: "#00e5ff", explode: false, trail: true, bassExplode: false },
                { name: "Lava", bg: "#3a0d00", color: "#ff6f00", explode: true, trail: true, bassExplode: true },
                { name: "Whiteout", bg: "#f8f9fa", color: "#adb5bd", explode: false, trail: false, bassExplode: false }
            ];

            // Surface 3D themes
            const surface3dThemes = [
                { name: "Classic", bg: "#181818", grid: "#fff", wire: false },
                { name: "Wireframe", bg: "#000", grid: "#fff", wire: true },
                { name: "Night", bg: "#0a0a23", grid: "#00eaff", wire: false },
                { name: "Inferno", bg: "#1a0000", grid: "#ff5400", wire: false },
                { name: "Rainbow", bg: "#222", grid: "#fff", wire: false },
                { name: "Matrix", bg: "#001a00", grid: "#00ff41", wire: true },
                { name: "Sunset", bg: "#220901", grid: "#ff7b00", wire: false },
                { name: "Ocean", bg: "#001f54", grid: "#00e5ff", wire: false },
                { name: "Lava", bg: "#3a0d00", grid: "#ff6f00", wire: false },
                { name: "Whiteout", bg: "#f8f9fa", grid: "#adb5bd", wire: false }
            ];

            // Set initial current visualizer text
            currentVisualizer.textContent = 'Classic Bars';

            // Create audio wave bars
            for (let i = 0; i < 50; i++) {
                const bar = document.createElement('div');
                bar.className = 'wave-bar';
                audioWave.appendChild(bar);
            }
            const waveBars = document.querySelectorAll('.wave-bar');

            // Initialize canvas size
            function resizeCanvas() {
                visualizerCanvas.width = visualizerCanvas.offsetWidth;
                visualizerCanvas.height = visualizerCanvas.offsetHeight;
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Audio setup
            async function setupAudio() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    
                    // Adjust FFT size based on sensitivity
                    analyser.fftSize = 2048;
                    
                    microphone = audioContext.createMediaStreamSource(stream);
                    microphone.connect(analyser);
                    
                    dataArray = new Uint8Array(analyser.frequencyBinCount);
                    
                    isRecording = true;
                    recordingIndicator.classList.add('active');
                    recordingStatus.textContent = 'Recording in progress';
                    recordButton.classList.add('recording');
                    recordButton.querySelector('.btn-text').textContent = 'Stop Recording';
                    
                    // Start visualization
                    visualize();
                } catch (err) {
                    console.error('Error accessing microphone:', err);
                    alert('Error accessing microphone. Please check your permissions and try again.');
                }
            }

            function stopAudio() {
                if (microphone && analyser) {
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                        animationId = null;
                    }
                    
                    microphone.disconnect();
                    microphone = null;
                    
                    if (audioContext) {
                        audioContext.close();
                        audioContext = null;
                    }
                    
                    isRecording = false;
                    recordingIndicator.classList.remove('active');
                    recordingStatus.textContent = 'Not recording';
                    recordButton.classList.remove('recording');
                    recordButton.querySelector('.btn-text').textContent = 'Start Recording';
                    
                    // Reset the wave bars
                    waveBars.forEach(bar => {
                        bar.style.height = '3px';
                    });
                }
            }

            // Visualization functions
            function visualize() {
                analyser.getByteFrequencyData(dataArray);
                
                // Clear canvas
                ctx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
                
                // Set visualization based on selected type
                switch (visualizerType) {
                    case 'bars':
                        drawBars();
                        break;
                    case 'circular':
                        drawCircular();
                        break;
                    case 'wave':
                        drawWave();
                        break;
                    case 'spectrum':
                        drawSpectrum();
                        break;
                    case 'particles':
                        drawParticles();
                        break;
                    case 'terrain':
                        draw3DTerrain();
                        break;
                    case 'starfield':
                        drawStarfield();
                        break;
                    case 'frequency':
                        drawFrequencyMesh();
                        break;
                    case 'orbs':
                        drawOrbs();
                        break;
                    case 'ripple':
                        drawRipple();
                        break;
                    case 'waveform':
                        drawWaveform();
                        break;
                    case 'fractal':
                        drawFractal();
                        break;
                    case 'spiral':
                        drawSpiral();
                        break;
                    case 'bubbles':
                        drawBubbles();
                        break;
                    case 'fireflies':
                        drawFireflies();
                        break;
                    case 'grid':
                        drawGrid();
                        break;
                    case 'tunnel':
                        drawTunnel();
                        break;
                    case 'galaxy':
                        drawGalaxy();
                        break;
                    case 'matrix':
                        drawMatrix();
                        break;
                    case 'surface3d':
                        drawSurface3D();
                        break;
                    default:
                        drawBars();
                }
                
                // Update the audio wave visualization
                updateAudioWave();
                
                // Continue animation
                animationId = requestAnimationFrame(visualize);
            }

            function updateAudioWave() {
                const barCount = waveBars.length;
                const step = Math.floor(dataArray.length / barCount);
                
                waveBars.forEach((bar, index) => {
                    const dataIndex = index * step;
                    const value = dataArray[dataIndex] / 255;
                    const height = Math.max(3, value * 50);
                    bar.style.height = `${height}px`;
                });
            }

            function drawBars() {
                const barCount = Math.floor(visualizerCanvas.width / 8);
                const barWidth = (visualizerCanvas.width / barCount) - 2;
                const heightMultiplier = visualizerCanvas.height / 255 * (intensity / 5);
                
                ctx.fillStyle = primaryColor.value;
                
                for (let i = 0; i < barCount; i++) {
                    const step = Math.floor(dataArray.length / barCount);
                    const value = dataArray[i * step] * (sensitivity / 5);
                    const barHeight = value * heightMultiplier;
                    const x = i * (barWidth + 2);
                    const y = visualizerCanvas.height - barHeight;
                    
                    // Create gradient
                    const gradient = ctx.createLinearGradient(x, y, x, visualizerCanvas.height);
                    gradient.addColorStop(0, primaryColor.value);
                    gradient.addColorStop(1, secondaryColor.value);
                    ctx.fillStyle = gradient;
                    
                    ctx.fillRect(x, y, barWidth, barHeight);
                }
            }

            function drawCircular() {
                const centerX = visualizerCanvas.width / 2;
                const centerY = visualizerCanvas.height / 2;
                const radius = Math.min(centerX, centerY) * 0.8 * (intensity / 5);
                const barCount = 180;
                const angleStep = (2 * Math.PI) / barCount;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
                ctx.fillStyle = primaryColor.value;
                ctx.fill();
                
                for (let i = 0; i < barCount; i++) {
                    const step = Math.floor(dataArray.length / barCount);
                    const value = dataArray[i * step] * (sensitivity / 5);
                    const barHeight = value * (radius / 255);
                    const angle = i * angleStep;
                    
                    const x1 = centerX + Math.cos(angle) * radius;
                    const y1 = centerY + Math.sin(angle) * radius;
                    const x2 = centerX + Math.cos(angle) * (radius + barHeight);
                    const y2 = centerY + Math.sin(angle) * (radius + barHeight);
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineWidth = 2;
                    
                    // Use the gradient based on the value
                    const hue = (i / barCount * 360) % 360;
                    ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
                    
                    ctx.stroke();
                }
            }

            function drawWave() {
                const width = visualizerCanvas.width;
                const height = visualizerCanvas.height;
                const centerY = height / 2;
                const points = width / 2;
                const smoothingFactor = speed / 10;
                
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                
                for (let i = 0; i < points; i++) {
                    const step = Math.floor(dataArray.length / points);
                    const value = dataArray[i * step] * (sensitivity / 5);
                    const amplitude = value * (height / 2) / 255 * (intensity / 5);
                    const x = i * (width / points);
                    const y = centerY + Math.sin(i * smoothingFactor) * amplitude;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                // Create gradient
                const gradient = ctx.createLinearGradient(0, 0, width, 0);
                gradient.addColorStop(0, primaryColor.value);
                gradient.addColorStop(0.5, secondaryColor.value);
                gradient.addColorStop(1, primaryColor.value);
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Mirror the wave for the bottom half
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                
                for (let i = 0; i < points; i++) {
                    const step = Math.floor(dataArray.length / points);
                    const value = dataArray[i * step] * (sensitivity / 5);
                    const amplitude = value * (height / 2) / 255 * (intensity / 5);
                    const x = i * (width / points);
                    const y = centerY - Math.sin(i * smoothingFactor) * amplitude;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            function drawSpectrum() {
                const width = visualizerCanvas.width;
                const height = visualizerCanvas.height;
                const barCount = Math.floor(width / 4);
                const barWidth = width / barCount - 1;
                
                ctx.fillStyle = primaryColor.value;
                
                for (let i = 0; i < barCount; i++) {
                    const step = Math.floor(dataArray.length / barCount);
                    const value = dataArray[i * step] * (sensitivity / 5);
                    
                    // Create a more interesting spectrum by using different height calculations
                    let barHeight;
                    if (i < barCount / 3) {
                        // Low frequencies
                        barHeight = value * (height / 255) * (0.5 + intensity / 10);
                    } else if (i < barCount * 2/3) {
                        // Mid frequencies
                        barHeight = value * (height / 255) * (0.7 + intensity / 10);
                    } else {
                        // High frequencies
                        barHeight = value * (height / 255) * (0.3 + intensity / 10);
                    }
                    
                    const x = i * (barWidth + 1);
                    const y = height - barHeight;
                    
                    // Create gradient for color transition
                    const hue = (i / barCount * 360) % 360;
                    ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                    
                    ctx.fillRect(x, y, barWidth, barHeight);
                    
                    // Add smaller reflection
                    const reflectionHeight = barHeight * 0.3;
                    const gradient = ctx.createLinearGradient(x, 0, x, reflectionHeight);
                    gradient.addColorStop(0, `hsla(${hue}, 100%, 50%, 0.1)`);
                    gradient.addColorStop(1, `hsla(${hue}, 100%, 50%, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, height, barWidth, -reflectionHeight);
                }
            }

            function drawParticles() {
                const width = visualizerCanvas.width;
                const height = visualizerCanvas.height;
                const centerX = width / 2;
                const centerY = height / 2;
                
                // Calculate the average intensity
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    sum += dataArray[i];
                }
                const avgIntensity = sum / dataArray.length * (sensitivity / 5);

                // Draw particles radiating from center
                const particleCount = 120 + Math.floor(intensity * 8);
                for (let i = 0; i < particleCount; i++) {
                    const idx = Math.floor(i / particleCount * dataArray.length);
                    const amp = dataArray[idx] / 255;
                    const angle = (i / particleCount) * Math.PI * 2 + performance.now() * 0.0002 * speed;
                    const r = (Math.min(centerX, centerY) * 0.5 + amp * 120) * (0.7 + intensity / 10);
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;
                    ctx.beginPath();
                    ctx.arc(x, y, 4 + amp * 12, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(0,229,255,${0.3 + amp * 0.7})`;
                    ctx.shadowColor = secondaryColor.value;
                    ctx.shadowBlur = 10 + amp * 30;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }

            function draw3DTerrain() {
                // 3D terrain-like frequency mesh using 2D canvas
                const width = visualizerCanvas.width;
                const height = visualizerCanvas.height;
                const cols = 64;
                const rows = 32;
                const cellW = width / cols;
                const cellH = height / rows;
                const freqStep = Math.floor(dataArray.length / cols);

                // Background gradient
                const grad = ctx.createLinearGradient(0, 0, 0, height);
                grad.addColorStop(0, primaryColor.value);
                grad.addColorStop(1, backgroundColor.value);
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, width, height);

                // Draw mesh
                ctx.save();
                ctx.globalAlpha = 0.85;
                for (let y = 0; y < rows; y++) {
                    ctx.beginPath();
                    for (let x = 0; x < cols; x++) {
                        // Simulate "height" using frequency data and a moving wave
                        const freqIdx = x * freqStep;
                        const freq = dataArray[freqIdx] || 0;
                        const t = performance.now() * 0.001 * (0.5 + speed / 10);
                        const z = Math.sin(t + x * 0.2 + y * 0.3) * 10 + (freq / 255) * 60 * (intensity / 5);
                        const px = x * cellW;
                        const py = y * cellH - z;
                        if (x === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.strokeStyle = secondaryColor.value;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.7;
                    ctx.stroke();
                }
                // Draw vertical mesh lines for 3D effect
                for (let x = 0; x < cols; x++) {
                    ctx.beginPath();
                    for (let y = 0; y < rows; y++) {
                        const freqIdx = x * freqStep;
                        const freq = dataArray[freqIdx] || 0;
                        const t = performance.now() * 0.001 * (0.5 + speed / 10);
                        const z = Math.sin(t + x * 0.2 + y * 0.3) * 10 + (freq / 255) * 60 * (intensity / 5);
                        const px = x * cellW;
                        const py = y * cellH - z;
                        if (y === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.strokeStyle = primaryColor.value;
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.4;
                    ctx.stroke();
                }
                ctx.restore();
            }

            function drawMatrix() {
                // Enhanced Matrix effect
                ctx.fillStyle = backgroundColor.value + "e6";
                ctx.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);

                ctx.font = `${matrixFontSize}px monospace`;
                ctx.textAlign = "center";
                const width = visualizerCanvas.width;
                const height = visualizerCanvas.height;
                const columns = Math.floor(width / matrixFontSize);

                // Initialize columns/drops if needed
                if (matrixColumns.length !== columns) setupMatrix();

                for (let i = 0; i < columns; i++) {
                    const char = matrixCharset.charAt(Math.floor(Math.random() * matrixCharset.length));
                    const x = matrixColumns[i];
                    const y = matrixDrops[i] * matrixFontSize;

                    // Color based on audio
                    const freqIdx = Math.floor(i / columns * dataArray.length);
                    const value = dataArray[freqIdx] || 0;
                    const green = Math.min(255, 100 + value);
                    ctx.fillStyle = `rgb(0,${green},70)`;
                    ctx.shadowColor = `rgb(0,${green},70)`;
                    ctx.shadowBlur = 10 + value / 8;

                    ctx.fillText(char, x + matrixFontSize / 2, y);

                    ctx.shadowBlur = 0;

                    // Move drop down, reset randomly
                    if (y > height && Math.random() > 0.975) {
                        matrixDrops[i] = 0;
                    }
                    matrixDrops[i] += matrixSpeed / 10;
                }
            }

            function setupMatrix() {
                // Calculate columns and drops for matrix effect
                const width = visualizerCanvas.width;
                const height = visualizerCanvas.height;
                const columns = Math.floor(width / matrixFontSize);
                matrixColumns = [];
                matrixDrops = [];
                for (let i = 0; i < columns; i++) {
                    matrixColumns[i] = i * matrixFontSize;
                    matrixDrops[i] = Math.random() * height / matrixFontSize;
                }
            }

            function drawStarfield() {
                // Starfield with theme and "exploding" feature
                const theme = starfieldThemes[currentStarfieldTheme];
                const width = visualizerCanvas.width;
                const height = visualizerCanvas.height;
                const numStars = 180 + intensity * 20;
                const centerX = width / 2;
                const centerY = height / 2;
                const maxDepth = 1.5 + intensity / 2;

                // Persist star positions and explosions between frames
                if (!drawStarfield.stars || drawStarfield.stars.length !== numStars) {
                    drawStarfield.stars = [];
                    drawStarfield.explosions = [];
                    for (let i = 0; i < numStars; i++) {
                        drawStarfield.stars.push({
                            x: (Math.random() - 0.5) * width,
                            y: (Math.random() - 0.5) * height,
                            z: Math.random() * maxDepth + 0.2,
                            color: theme.color
                        });
                    }
                }
                const stars = drawStarfield.stars;
                const explosions = drawStarfield.explosions || [];

                // Background
                ctx.save();
                ctx.fillStyle = theme.bg;
                ctx.globalAlpha = 0.9;
                ctx.fillRect(0, 0, width, height);
                ctx.globalAlpha = 1;

                // Optional trail effect
                if (theme.trail) {
                    ctx.globalAlpha = 0.18;
                    ctx.fillStyle = theme.bg;
                    ctx.fillRect(0, 0, width, height);
                    ctx.globalAlpha = 1;
                }

                // Animate and draw stars
                for (let i = 0; i < stars.length; i++) {
                    let star = stars[i];
                    // Move star forward (simulate speed)
                    star.z -= 0.01 * (speed / 5 + 0.5);
                    if (star.z <= 0.1) {
                        // Reset star to far plane
                        star.x = (Math.random() - 0.5) * width;
                        star.y = (Math.random() - 0.5) * height;
                        star.z = maxDepth;
                    }
                    // Project 3D to 2D
                    const sx = centerX + (star.x / star.z);
                    const sy = centerY + (star.y / star.z);

                    // Color and size based on depth and audio
                    const freqIdx = Math.floor(i / stars.length * dataArray.length);
                    const amp = dataArray[freqIdx] / 255;
                    let color = theme.color;
                    let hue = 180 + amp * 180;
                    let size = Math.max(1, (1.5 - star.z) * 2 + amp * 2);

                    // Exploding effect for bass or high amplitude
                    let shouldExplode = false;
                    if (theme.explode && amp > 0.85) {
                        shouldExplode = true;
                    }
                    if (theme.bassExplode && freqIdx < 10 && amp > 0.7) {
                        shouldExplode = true;
                    }
                    if (shouldExplode) {
                        // Add explosion
                        explosions.push({
                            x: sx,
                            y: sy,
                            color: color,
                            radius: size * 2,
                            alpha: 1,
                            t: 0,
                            hue: hue
                        });
                    }

                    ctx.beginPath();
                    ctx.arc(sx, sy, size, 0, Math.PI * 2);
                    ctx.fillStyle = color.startsWith('#') ? color : `hsl(${hue}, 100%, ${60 + amp * 30}%)`;
                    ctx.globalAlpha = 0.7 + amp * 0.3;
                    ctx.shadowColor = color.startsWith('#') ? color : `hsl(${hue}, 100%, 80%)`;
                    ctx.shadowBlur = 8 + amp * 10;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                }

                // Draw and update explosions
                for (let i = explosions.length - 1; i >= 0; i--) {
                    let ex = explosions[i];
                    ex.radius += 2 + Math.random() * 2;
                    ex.alpha -= 0.04 + Math.random() * 0.02;
                    ex.t += 1;
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
                    ctx.globalAlpha = Math.max(0, ex.alpha);
                    ctx.strokeStyle = ex.color.startsWith('#') ? ex.color : `hsl(${ex.hue}, 100%, 80%)`;
                    ctx.lineWidth = 2 + Math.random() * 2;
                    ctx.shadowColor = ctx.strokeStyle;
                    ctx.shadowBlur = 12;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                    ctx.restore();
                    if (ex.alpha <= 0) {
                        explosions.splice(i, 1);
                    }
                }
                drawStarfield.explosions = explosions;
                ctx.restore();
            }

            function drawSurface3D() {
                const theme = surface3dThemes[currentSurface3dTheme];
                const width = visualizerCanvas.width;
                const height = visualizerCanvas.height;
                const cols = 64;
                const rows = 32;
                const cellW = width / cols;
                const cellH = height / rows;
                const freqStep = Math.floor(dataArray.length / cols);

                // 3D params
                const perspective = surface3dPerspective;
                const rot = surface3dRotation;
                const camZ = 600;
                const camY = 180;

                // Prepare mesh data
                let mesh = [];
                for (let y = 0; y < rows; y++) {
                    let row = [];
                    for (let x = 0; x < cols; x++) {
                        const freqIdx = x * freqStep;
                        const freq = dataArray[freqIdx] || 0;
                        // Z height: combine freq and a moving wave
                        const t = performance.now() * 0.001 * (0.5 + speed / 10);
                        const z = Math.sin(t + x * 0.2 + y * 0.3) * 10 + (freq / 255) * 120 * (intensity / 5);
                        row.push(z);
                    }
                    mesh.push(row);
                }

                // Background
                ctx.save();
                ctx.fillStyle = theme.bg;
                ctx.fillRect(0, 0, width, height);

                // Project and draw mesh
                function project3D(x, y, z) {
                    // Center mesh
                    x -= cols / 2;
                    y -= rows / 2;
                    // Rotate around Y axis
                    const xr = x * Math.cos(rot) - z * Math.sin(rot);
                    const zr = x * Math.sin(rot) + z * Math.cos(rot);
                    // Perspective projection
                    const scale = camZ / (camZ + zr * perspective + 1);
                    return [
                        width / 2 + xr * cellW * scale,
                        height * 0.7 + y * cellH * scale - (z * scale) / 2
                    ];
                }

                // Draw surface
                for (let y = 0; y < rows - 1; y++) {
                    ctx.beginPath();
                    for (let x = 0; x < cols; x++) {
                        const z = mesh[y][x];
                        const [px, py] = project3D(x, y, z);
                        if (x === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    // Color by height
                    const t = Math.max(0, Math.min(1, (Math.max(...mesh[y]) - Math.min(...mesh[y])) ? (Math.max(...mesh[y]) - Math.min(...mesh[y])) / 120 : 0));
                    ctx.strokeStyle = getColormapColor(surface3dColormapValue, t);
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.9;
                    ctx.stroke();
                }
                // Draw vertical mesh lines for 3D effect
                for (let x = 0; x < cols; x += 2) {
                    ctx.beginPath();
                    for (let y = 0; y < rows; y++) {
                        const z = mesh[y][x];
                        const [px, py] = project3D(x, y, z);
                        if (y === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.strokeStyle = theme.grid;
                    ctx.lineWidth = theme.wire ? 1 : 0.5;
                    ctx.globalAlpha = theme.wire ? 0.7 : 0.3;
                    ctx.stroke();
                }

                // Movable canvas bars to fill the mountain (frequency bars in 3D)
                for (let x = 0; x < cols; x++) {
                    const freqIdx = x * freqStep;
                    const freq = dataArray[freqIdx] || 0;
                    const barHeight = (freq / 255) * 120 * (intensity / 5);
                    // Project bar base and tip
                    const [baseX, baseY] = project3D(x, rows - 1, 0);
                    const [topX, topY] = project3D(x, rows - 1, barHeight);
                    // Color by frequency (rainbow)
                    ctx.beginPath();
                    ctx.moveTo(baseX, baseY);
                    ctx.lineTo(topX, topY);
                    ctx.strokeStyle = getColormapColor("rainbow", freqIdx / dataArray.length);
                    ctx.lineWidth = 4;
                    ctx.globalAlpha = 0.95;
                    ctx.shadowColor = ctx.strokeStyle;
                    ctx.shadowBlur = 8;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                ctx.globalAlpha = 1;
                ctx.restore();
            }

            function getColormapColor(map, t) {
                // t in [0,1]
                if (map === "rainbow") {
                    const h = 240 - 240 * t;
                    return `hsl(${h},100%,50%)`;
                }
                if (map === "hot") {
                    const r = Math.min(255, 255 * t * 2);
                    const g = Math.min(255, 255 * (t - 0.5) * 2);
                    const b = Math.max(0, 255 * (t - 0.8) * 5);
                    return `rgb(${Math.round(r)},${Math.round(g)},${Math.round(b)})`;
                }
                if (map === "cool") {
                    return `rgb(${Math.round(0)},${Math.round(255 * t)},${Math.round(255 * (1 - t))})`;
                }
                if (map === "inferno") {
                    // Approximate inferno
                    const r = Math.round(255 * Math.pow(t, 0.5));
                    const g = Math.round(80 * Math.pow(t, 1.5));
                    const b = Math.round(30 + 180 * (1 - t));
                    return `rgb(${r},${g},${b})`;
                }
                if (map === "magma") {
                    // Approximate magma
                    const r = Math.round(255 * Math.pow(t, 0.7));
                    const g = Math.round(60 * Math.pow(t, 1.2));
                    const b = Math.round(80 + 120 * (1 - t));
                    return `rgb(${r},${g},${b})`;
                }
                if (map === "viridis") {
                    // Approximate viridis
                    const r = Math.round(68 + 187 * t);
                    const g = Math.round(1 + 253 * t);
                    const b = Math.round(84 + 67 * (1 - t));
                    return `rgb(${r},${g},${b})`;
                }
                return "#fff";
            }

            function drawGalaxy() {
                // Upscaled, realistic galaxy visual preset
                const width = visualizerCanvas.width;
                const height = visualizerCanvas.height;
                const centerX = width / 2;
                const centerY = height / 2;
                const numStars = 2000 + intensity * 400;
                const spiralArms = 5;
                const armSpread = 0.25 + 0.15 * (intensity / 10);
                const coreRadius = Math.min(width, height) * 0.08;
                const galaxyRadius = Math.min(width, height) * 0.48;
                const time = performance.now() * 0.00008 * speed;

                // Background
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.fillStyle = "#070014";
                ctx.fillRect(0, 0, width, height);

                // Draw core glow
                const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreRadius * 2.5);
                coreGradient.addColorStop(0, "rgba(255,255,255,0.7)");
                coreGradient.addColorStop(0.2, "rgba(255,200,255,0.25)");
                coreGradient.addColorStop(1, "rgba(20,0,40,0)");
                ctx.beginPath();
                ctx.arc(centerX, centerY, coreRadius * 2.5, 0, Math.PI * 2);
                ctx.fillStyle = coreGradient;
                ctx.fill();

                // Draw spiral arms
                for (let i = 0; i < numStars; i++) {
                    // Arm index and angle
                    const arm = i % spiralArms;
                    const armAngle = (arm / spiralArms) * Math.PI * 2;
                    // Distance from center
                    const t = Math.pow(Math.random(), 1.5);
                    const r = coreRadius + t * (galaxyRadius - coreRadius);
                    // Spiral angle with some noise
                    const angle = armAngle + t * 4.5 + (Math.random() - 0.5) * armSpread + time * (0.2 + 0.8 * t);
                    // Star position
                    const x = centerX + Math.cos(angle) * r + (Math.random() - 0.5) * 8 * (1 - t);
                    const y = centerY + Math.sin(angle) * r + (Math.random() - 0.5) * 8 * (1 - t);

                    // Color and size by distance and audio
                    const freqIdx = Math.floor((t * dataArray.length) % dataArray.length);
                    const amp = dataArray[freqIdx] / 255;
                    let color;
                    if (t < 0.15) {
                        color = "rgba(255,255,255,0.9)";
                    } else if (t < 0.3) {
                        color = `rgba(255,220,255,${0.7 + amp * 0.2})`;
                    } else if (t < 0.7) {
                        color = `rgba(${180 + amp * 60},${180 + amp * 40},255,${0.5 + amp * 0.3})`;
                    } else {
                        color = `rgba(${100 + amp * 80},${120 + amp * 60},${255 - amp * 80},${0.2 + amp * 0.2})`;
                    }
                    const size = 0.7 + Math.pow(1 - t, 2) * 2.5 + amp * 1.2;

                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 6 + amp * 8;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                // Draw nebula clouds
                for (let n = 0; n < 4; n++) {
                    const nebAngle = time * 0.5 + n * Math.PI / 2;
                    const nebRadius = coreRadius * (1.8 + n * 0.7);
                    const nx = centerX + Math.cos(nebAngle) * nebRadius;
                    const ny = centerY + Math.sin(nebAngle) * nebRadius;
                    const nebGrad = ctx.createRadialGradient(nx, ny, 0, nx, ny, coreRadius * (1.2 + n * 0.4));
                    nebGrad.addColorStop(0, `rgba(120,80,255,${0.12 + 0.08 * n})`);
                    nebGrad.addColorStop(1, "rgba(20,0,40,0)");
                    ctx.beginPath();
                    ctx.arc(nx, ny, coreRadius * (1.2 + n * 0.4), 0, Math.PI * 2);
                    ctx.fillStyle = nebGrad;
                    ctx.fill();
                }

                ctx.restore();
            }

            function drawFractal() {
                // Mandelbrot fractal with audio-driven color and zoom
                const width = visualizerCanvas.width;
                const height = visualizerCanvas.height;
                const maxIter = 80 + Math.floor(intensity * 12);
                const zoom = 1.5 - (Math.max(0, Math.min(1, (intensity - 1) / 9))) * 1.2;
                const offsetX = -0.6 + Math.sin(performance.now() * 0.0001 * speed) * 0.2;
                const offsetY = 0 + Math.cos(performance.now() * 0.00013 * speed) * 0.2;

                // Get average frequency for color modulation
                let avg = 0;
                for (let i = 0; i < dataArray.length; i++) avg += dataArray[i];
                avg = avg / dataArray.length / 255;

                // Render fractal
                const img = ctx.createImageData(width, height);
                const data = img.data;
                for (let py = 0; py < height; py += 2) {
                    for (let px = 0; px < width; px += 2) {
                        // Map pixel to complex plane
                        const x0 = ((px / width) * 3.5 - 2.5) * zoom + offsetX;
                        const y0 = ((py / height) * 2.0 - 1.0) * zoom + offsetY;
                        let x = 0, y = 0, iter = 0;
                        while (x * x + y * y <= 4 && iter < maxIter) {
                            const xtemp = x * x - y * y + x0;
                            y = 2 * x * y + y0;
                            x = xtemp;
                            iter++;
                        }
                        // Color: audio modulates hue and brightness
                        let hue = (220 + (px / width) * 120 + avg * 120 + Math.sin(py * 0.01 + performance.now() * 0.0005 * speed) * 40) % 360;
                        let sat = 80 + Math.sin(iter + avg * 10) * 20;
                        let light = iter < maxIter ? 40 + (iter / maxIter) * 60 : 0;
                        if (iter === maxIter) {
                            hue = 0; sat = 0; light = 0;
                        }
                        // Set pixel (draw 2x2 block for speed)
                        for (let dy = 0; dy < 2; dy++) {
                            for (let dx = 0; dx < 2; dx++) {
                                const idx = 4 * ((py + dy) * width + (px + dx));
                                const rgb = hslToRgb(hue / 360, sat / 100, light / 100);
                                data[idx] = rgb[0];
                                data[idx + 1] = rgb[1];
                                data[idx + 2] = rgb[2];
                                data[idx + 3] = 255;
                            }
                        }
                    }
                }
                ctx.putImageData(img, 0, 0);
            }

            // Helper: HSL to RGB
            function hslToRgb(h, s, l) {
                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    function hue2rgb(p, q, t) {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    }
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1 / 3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1 / 3);
                }
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }

            // Update visualizerType on select
            visualizationType.addEventListener('change', function() {
                visualizerType = visualizationType.value;
                currentVisualizer.textContent = visualizationType.options[visualizationType.selectedIndex].text;
                matrixSettingsGroup.style.display = (visualizerType === 'matrix') ? 'block' : 'none';
                starfieldThemesGroup.style.display = (visualizerType === 'starfield') ? 'block' : 'none';
                surface3dSettingsGroup.style.display = (visualizerType === 'surface3d') ? 'block' : 'none';
                if (visualizerType === 'matrix') {
                    setupMatrix();
                }
            });

            // Matrix settings events
            matrixFontSizeSlider.addEventListener('input', function() {
                matrixFontSize = parseInt(matrixFontSizeSlider.value);
                matrixFontSizeValue.textContent = matrixFontSize;
                if (visualizerType === 'matrix') setupMatrix();
            });
            matrixSpeedSlider.addEventListener('input', function() {
                matrixSpeed = parseInt(matrixSpeedSlider.value);
                matrixSpeedValue.textContent = matrixSpeed;
            });
            matrixCharsetInput.addEventListener('input', function() {
                matrixCharset = matrixCharsetInput.value || "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
                if (visualizerType === 'matrix') setupMatrix();
            });

            // Build theme buttons
            starfieldThemes.forEach((theme, idx) => {
                const btn = document.createElement('button');
                btn.className = 'preset-btn' + (idx === 0 ? ' active' : '');
                btn.textContent = theme.name;
                btn.dataset.themeIdx = idx;
                btn.addEventListener('click', function() {
                    document.querySelectorAll('#starfieldThemeButtons .preset-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentStarfieldTheme = idx;
                });
                starfieldThemeButtons.appendChild(btn);
            });

            surface3dThemes.forEach((theme, idx) => {
                const btn = document.createElement('button');
                btn.className = 'preset-btn' + (idx === 0 ? ' active' : '');
                btn.textContent = theme.name;
                btn.dataset.themeIdx = idx;
                btn.addEventListener('click', function() {
                    document.querySelectorAll('#surface3dThemeButtons .preset-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentSurface3dTheme = idx;
                });
                surface3dThemeButtons.appendChild(btn);
            });

            surface3dColormap.addEventListener('change', function() {
                surface3dColormapValue = surface3dColormap.value;
            });
            surface3dPerspectiveSlider.addEventListener('input', function() {
                surface3dPerspective = parseFloat(surface3dPerspectiveSlider.value);
                surface3dPerspectiveValue.textContent = surface3dPerspective;
            });
            surface3dRotationSlider.addEventListener('input', function() {
                surface3dRotation = parseFloat(surface3dRotationSlider.value);
                surface3dRotationValue.textContent = surface3dRotation;
            });

            // Preset buttons
            presetButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    presetButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    switch (btn.dataset.preset) {
                        case 'default':
                            primaryColor.value = '#9d46ff';
                            secondaryColor.value = '#00e5ff';
                            backgroundColor.value = '#121212';
                            break;
                        case 'neon':
                            primaryColor.value = '#ff00c8';
                            secondaryColor.value = '#00fff7';
                            backgroundColor.value = '#0a0026';
                            break;
                        case 'minimal':
                            primaryColor.value = '#ffffff';
                            secondaryColor.value = '#bdbdbd';
                            backgroundColor.value = '#232323';
                            break;
                        case 'dark':
                            primaryColor.value = '#22223b';
                            secondaryColor.value = '#4a4e69';
                            backgroundColor.value = '#121212';
                            break;
                        case 'retro':
                            primaryColor.value = '#ffbe0b';
                            secondaryColor.value = '#fb5607';
                            backgroundColor.value = '#3a0ca3';
                            break;
                    }
                    updateTheme();
                });
            });

            // Color pickers
            [primaryColor, secondaryColor, backgroundColor].forEach(input => {
                input.addEventListener('input', updateTheme);
            });

            function updateTheme() {
                document.documentElement.style.setProperty('--primary', primaryColor.value);
                document.documentElement.style.setProperty('--secondary', secondaryColor.value);
                document.documentElement.style.setProperty('--background', backgroundColor.value);
            }

            // Sliders
            sensitivitySlider.addEventListener('input', function() {
                sensitivity = parseInt(sensitivitySlider.value);
                sensitivityValue.textContent = sensitivity;
            });
            speedSlider.addEventListener('input', function() {
                speed = parseInt(speedSlider.value);
                speedValue.textContent = speed;
            });
            intensitySlider.addEventListener('input', function() {
                intensity = parseInt(intensitySlider.value);
                intensityValue.textContent = intensity;
            });

            // Microphone record button
            recordButton.addEventListener('click', function() {
                if (!isRecording) {
                    setupAudio();
                } else {
                    stopAudio();
                }
            });

            // Fullscreen toggle
            fullscreenButton.addEventListener('click', function() {
                if (!document.fullscreenElement) {
                    if (visualizerContainer.requestFullscreen) {
                        visualizerContainer.requestFullscreen();
                    } else if (visualizerContainer.webkitRequestFullscreen) {
                        visualizerContainer.webkitRequestFullscreen();
                    } else if (visualizerContainer.msRequestFullscreen) {
                        visualizerContainer.msRequestFullscreen();
                    }
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) {
                        document.msExitFullscreen();
                    }
                }
            });

            // Optionally, auto-hide controls in fullscreen for immersive experience
            document.addEventListener('fullscreenchange', function() {
                if (document.fullscreenElement) {
                    document.querySelector('.controls-container').style.opacity = 0.1;
                    document.querySelector('.controls-container').style.pointerEvents = 'none';
                } else {
                    document.querySelector('.controls-container').style.opacity = 1;
                    document.querySelector('.controls-container').style.pointerEvents = 'auto';
                }
            });

            // Floating album art in center
            function drawAlbumArt() {
                // Do nothing (removed)
            }

            // Responsive canvas
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Initial theme
            updateTheme();

        });
    </script>
</body>
</html>